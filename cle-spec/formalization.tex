\documentclass{article}
\usepackage[utf8]{inputenc}

\title{CLE Type System}
\author{Benjamin Flin}
\date{August 2021}

\newcommand{\vertrule}[1][1ex]{\rule{.4pt}{#1}}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amssymb, proof, comment, syntax, url, amsthm, ebproof, mathtools}
\begin{document}

\maketitle

\section{Introduction}
\section{CLE Types Grammar}
The following is a small grammar for CLE types $\tau$. 
$l$ and $r$ represent levels and can be thought of as arbitrary identifiers.

\begin{center}
\begin{tabular}{ l r }
    $\tau, \pi, \gamma$ $\Coloneqq$ l $\phi$ $\bigl\vert$ l $\sigma$ ($\alpha_1$, $\dots$, $\alpha_n$) $\rightarrow_\phi$ $\theta$ & cle type \\
    $\alpha, \beta, \phi, \theta, \omega$ $\Coloneqq$ $\sigma$ $\bigl\vert$ $\sigma$ $\vertrule[1.5ex]$ $\phi$ & taints \\
    $\sigma$ $\Coloneqq$ $\epsilon$ $\bigl\vert$ $\sigma$ $+$ $r$ & remote levels \\
\end{tabular}
\end{center}
Note: remote levels are treated as sets. Taints are treated as sets of remotelevels (i.e., sets of sets of identifiers).

\section{LLVM core grammar}

The following source grammar represents an idealized subset of LLVM. 
Many operations are missing, but every missing operation can either be constructed from multiple instructions or is irrelevant to the CLE type inference and checking. 
The rules for cle types in the core grammar should represent the small grammar cle types above.
My references for the grammar construction is from this\footnote{\url{https://lists.llvm.org/pipermail/llvm-dev/2018-June/123851.html}} mail resource.

\begin{grammar}

<prog> ::= empty
\alt <prog> <top-level-entity> 

<top-level-entity> ::= <fun-def>
\alt <fun-decl>
\alt <global-def>
\alt <global-decl>

<global-def> ::= <global-ident> : <type> `=' <const>`;'

<global-decl> ::= <global-ident> : <type> `;'

<fun-def> ::= `define' <global-ident>`(' <params> `)' : <type> <func-body>

<fun-decl> ::= `declare' <global-ident>`(' <params> `)' : <type> `;' 

<params> ::= empty
\alt <param-list>

<param-list> ::= <local-ident>
\alt <param-list>`,' <local-ident> 

<global-ident> ::= `@'<ident>

<local-ident> ::= `\%'<ident>

<func-body> ::= `{' <block-list> `}'

<block-list> ::= <block>
\alt <block-list> <block>

<block> ::= <ident>`:' <instructions> <terminator>

<instructions> ::= empty
\alt <instructions> <instruction>`;'

<instruction> ::= <store-instr> 
\alt <load-instr>
\alt <alloca-instr>
\alt <gep-instr>
\alt <call-instr> 
\alt <binary-instr>
\alt <cast-instr>
\alt <const-instr>

<terminator> ::= <br-term>
\alt <ret-term> 

<decl> ::= <local-ident> : <type>

<store-instr> ::= `store' <value>, <local-ident>

<load-instr> ::= <decl> `=' `load' <value>, <local-ident>

<alloca-instr> ::= <decl> `=' `alloca' <llvm-type> 

<call-instr> ::= <decl> `=' <global-ident>`(' <params> `)'  

<gep-instr> ::= <decl> `=' `gep' <local-ident>`,' <nats> 

<binary-instr> ::= <decl> `=' <value> <binop> <value> 

<cast-instr> ::= <decl> `=' `cast' <local-ident> <llvm-type>  

<nats> ::= <nat>
\alt <nat>, <nats> 

<br-term> ::= `br' <local-ident>, <local-ident>, <local-ident> 
<ret-term> ::= `ret' <local-ident> 

<value> ::= <const>
\alt <local-ident>
\alt <global-ident>

<const> ::= <integer-literal>
\alt <bool-literal>
\alt <float-literal>
\alt <unit-literal>
\alt <struct-const>
\alt <array-const>

<type> ::= <llvm-type> `+' <cle-type>
\alt <llvm-type>

<llvm-type> ::= <int-type>
\alt <float-type>
\alt <unit-type> 
\alt <array-type>
\alt <pointer-type>
\alt <struct-type>
\alt <function-type>

<function-type> ::= `(' <llvm-type-list> `)' `->' <llvm-type>

<array-type> ::= `[' <nat> `x' <llvm-type> `]'

<pointer-type> ::= <llvm-type>`*'

<struct-type> ::= `{' <llvm-type-list> `}'

<llvm-type-list> ::= <llvm-type>
\alt <llvm-type-list>`,' <llvm-type>

<int-type> ::= `i'<nat>

<float-type> ::= `float' 
\alt `double'

<unit-type> ::= `unit'

<cle-type> ::= <level> <remote-levels> 
\alt <level> <remote-levels> `(' <cle-args> `)' `[' <taints> `]' `->' <taints> 

<cle-args> ::= <cle-args>, <taints> \alt empty

<taints> ::=  <taints> `|' <remote-levels> \alt <taints> 

<remote-levels> ::=  <remote-levels> `+' <level> \alt empty 

\end{grammar}

\section{Small examples}

This global viarable is in level purple, and is not shareable.
\begin{verbatim}
@foo : i64 + "purple" = 1;
\end{verbatim}


This global variable is in level orange, and is shareable with purple.
\begin{verbatim}
@foo : i64 + "orange" "purple" = 1;
\end{verbatim}

The following function has a proposed type \texttt{"orange" "purple" (empty, "purple" | empty) [empty] -> empty}.
It is in level "orange", and is callable from remote level "purple".
The first argument is not shareable, 
the second argument is either shareable with purple or not shareable. 
Any variable bound in the body must not be shareable, as well as the return type.

\begin{verbatim}
define @average(%0, %1) : (double, double) -> double
 + "orange" "purple" (empty, "purple" | empty) [empty] -> empty
      
{
   %2 : double + "orange" = %0 + %1;
   %3 : double + "orange" = %2 / 2.0;
   ret %3
}
\end{verbatim}

\section{Type rules}
Here we assume all functions and global variables have cle types associated with them.  We will focus on how to infer such types in the next section.
CLE is a flow-sensitive model and the types of variables may change as the program is checked.
To reason through this in the system, a type judgement will also include an output context, which may be used in the conclusions of judgements.

There are several types of judgements, each of which is enumerated below:

\subsection{Judgements}
\begin{enumerate}
    \item $\Gamma \vdash e : \tau$. 
    Top-level entity $e$ has type $\tau$. Top-level judgements are not flow-sensitive. 
    \item $\Gamma \vdash b :_\pi \gamma, \Gamma'$. 
    Basic block or set of basic blocks $b$ has type $\pi$ for all variables bound in instructions, type $\gamma$ for the terminator and produces a new context $\Gamma'$.
    \item $\Gamma \vdash t :_\pi \gamma, \Gamma'$. 
    Terminator $t$ has type $\gamma$ and all referenced basic blocks, $b$ are given type $_\pi \gamma$.
\end{enumerate}

\subsection{Rules for top-level entities}

\[    
\begin{prooftree}
    \hypo{\tau = l\ \phi}
    \infer1[global-decl]{\Gamma \vdash @x : \tau}
\end{prooftree}
\qquad
\begin{prooftree}
    \hypo{\tau = l\ \phi}
    \infer1[global-def]{\Gamma \vdash @x = c : \tau}
\end{prooftree}
\]

\[
\begin{prooftree}
    \hypo{
    \begin{matrix}
        \Gamma[@f \mapsto \tau, \%1 \mapsto l\ \alpha_1, \ldots, \%n \mapsto l\ \alpha_n] \vdash body :_{(l\ \phi_m)} l\ \theta_m, \Gamma' \\
        \tau = l\ \sigma\ (\alpha_1, \dots, \alpha_n) \rightarrow_\phi \theta
    \end{matrix}
    }
    \infer1[fn-def]{\Gamma \vdash @f(\%1, \dots \%n) : \tau\ \{ body \} : \Gamma'(@f)  }
    
\end{prooftree}
\]

\[
\begin{prooftree}
    \hypo{
    \Gamma(@f) = l\ \sigma\ (\alpha_1, \dots, \alpha_n) \rightarrow_\phi \theta
    }
    \infer1[fn-def-known]{\Gamma \vdash @f(\%1, \dots \%n) : \tau\ \{ body \} : \Gamma(@f)  }
\end{prooftree}
\]

\subsection{Rules for basic blocks and instruction lists}

\[
\begin{prooftree} 
    \hypo{\Gamma \vdash b :_\pi \gamma, \Gamma'}
    \hypo{\Gamma', \%b :_\pi \gamma \vdash bbs :_\pi \gamma, \Gamma''}
    \infer2[fn-body]{\Gamma \vdash b\ bbs :_\pi \gamma, \Gamma''}
\end{prooftree} 
\]


\[
\begin{prooftree} 
    \hypo{\Gamma \vdash instrs : \pi, \Gamma'}
    \hypo{\Gamma' \vdash term :_\pi \gamma, \Gamma''}
    \infer2[bb-unknown]{\Gamma \vdash \%b: instrs\ term :_\pi \gamma, \Gamma''}
\end{prooftree} 
\]


\[
\begin{prooftree} 
    \hypo{\Gamma(\%b) =_\pi \gamma} 
    \infer1[bb-known]{\Gamma \vdash \%b: instrs\ term :_\pi \gamma, \Gamma''}
\end{prooftree} 
\]


\[
\begin{prooftree} 
    \hypo{\Gamma \vdash instr : \pi, \Gamma'}
    \hypo{\Gamma' \vdash instrs : \pi, \Gamma''}
    \infer2[instrs]{\Gamma \vdash instr; instrs : \pi, \Gamma''}
\end{prooftree} 
\]

\subsection{Rules for special instructions and terminators}

\[
\begin{prooftree}
    \hypo{\Gamma(\%1) = l\ \alpha_1, \dots, \Gamma(\%n) = l\ \alpha_n}
    \hypo{
        \begin{matrix}
            \Gamma \vdash @f : l\ \sigma\ (\beta_1, \dots, \beta_n) \rightarrow_\phi \theta \\
            \omega \cap \theta \neq \varnothing
        \end{matrix}}
    \hypo{
        \begin{matrix}
        \alpha_1 \cap \beta_1 \neq \varnothing \\
        \vdots \\
        \alpha_n \cap \beta_n \neq \varnothing
        \end{matrix}
    }
    \infer3[call]{
    \begin{matrix}
        \Gamma \vdash \%a = \text{call } @f(\%1, \dots, \%n) : l\ \omega, \\
        \Gamma[\%a \mapsto l\ \omega \cap \theta, @f \mapsto (\alpha_1 \cap \beta_1, \dots, \alpha_n \cap \beta_n) \rightarrow_\phi \theta, \%1 \mapsto l\ \alpha_1 \cap \beta_1, \dots, \%n \mapsto l\ \alpha_n \cap \beta_n]
    \end{matrix}}
\end{prooftree}
\]

\[
\begin{prooftree}
    \hypo{\Gamma(\%1) = l\ \alpha_1, \dots, \Gamma(\%n) = l\ \alpha_n}
    \hypo{\Gamma(@f) = r\ \sigma\ (\beta_1, \dots, \beta_n) \rightarrow_\phi \theta}
    \hypo{l \neq r}
    \hypo{l \in \sigma}
    \infer4[xd-call]{\Gamma \vdash \text{call } @f(\%1, \dots, \%n) : \pi, \Gamma}
\end{prooftree}
\]

\[
\begin{prooftree}
    \hypo{\Gamma(\%a) = \gamma}
    \hypo{\Gamma \vdash \%b_1 :_\pi \gamma, \Gamma'} 
    \hypo{\Gamma \vdash \%b_2 :_\pi \gamma, \Gamma''} 
    \infer3[break]{\Gamma \vdash \text{br }\%a, \%b_1, \%b_2 :_\pi \gamma, \Gamma' \cap \Gamma''}
\end{prooftree}
\]

\[
\begin{prooftree}
    \hypo{\Gamma(\%a) = \gamma}
    \infer1[ret]{\Gamma \vdash \text{ret }\%a :_\pi \gamma, \Gamma}
\end{prooftree}
\]

\subsection{Operations on contexts, taints and remotelevels }

The following operations turn taints and remotelevels into
sets of sets and sets respectively.
\[
\begin{prooftree}
    \infer0[set-epsilon]{S(\epsilon) = \varnothing}
\end{prooftree}
\]

\[
\begin{prooftree}
    \hypo{S(\sigma) = A} 
    \infer1[set-plus]{S(\sigma + r) = A \cup \{r\}}
\end{prooftree}
\]

\[
\begin{prooftree}
    \hypo{S(\sigma) = A} 
    \infer1[set-taint1]{S(\phi = \sigma) = \{A\}}
\end{prooftree}
\]

\[
\begin{prooftree}
    \hypo{S(\phi) = A}
    \hypo{S(\sigma) = B}
    \infer2[set-taint-many]{S(\phi \mid \sigma) = A \cup \{B\}}
\end{prooftree}
\]

$S^{-1}$ is ommitted, but can be thought as a inverse transformation from sets 
back to taints and remotelevels.


\[
\begin{prooftree}
    \hypo{S(\sigma_1) = A}
    \hypo{S(\sigma_2) = B}
    \infer2[intersect-level]{\sigma_1 \cap \sigma_2 = A \cap B}
\end{prooftree}
\]


\[
\begin{prooftree}
    \hypo{S(\phi_1) = A}
    \hypo{S(\phi_2) = B}
    \infer2[intersect-taint]{\phi_1 \cap \phi_2 = A \cap B}
\end{prooftree}
\]

Intersection on contexts is defined as a map merge with any overlapping types being
intersected.


\end{document}
