\documentclass{article}
\usepackage[utf8]{inputenc}

\title{CLE Type System}
\author{Benjamin Flin}
\date{August 2021}

\newcommand{\vertrule}[1][1ex]{\rule{.4pt}{#1}}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amssymb, proof, comment, syntax, url, amsthm, ebproof, mathtools}
\begin{document}

\maketitle

\section{Introduction}
\section{CLE Types Grammar}
The following is a small grammar for CLE types $\tau$. 
$l$ and $r$ represent enclaves and can be thought of as arbitrary identifiers.
$\alpha, \beta, \theta, \sigma$ are sets of remote enclaves, while $\delta$ is a set of $\mu$.
\begin{center}
\begin{tabular}{ l r }
    $\tau, \pi, \gamma$ $\Coloneqq$ $l\ \sigma$ $\bigl\vert$ $l\ \delta$ \\
    $\mu$ $\Coloneqq$ $r$ ($\alpha_1$, $\dots$, $\alpha_n$) $\rightarrow_\phi$ $\theta$ \\
\end{tabular}
\end{center}


$l\ \sigma$ describes a variable in enclave $l$ which can be shared with enclaves inside $\sigma$. 
The inhabitants of $l\ \delta$ are functions in the enclave $l$. For every $r\ (\alpha_1, \dots, \alpha_n) \rightarrow_\phi \theta \in \delta$
every function whose type is $l\ \delta$ can be called from an enclave r with
arguments whose shareability is $\alpha_1, \dots, \alpha_n$, whose function body can share with $\phi$ and whose
return is able to be shared with $\theta$.

The terms of the inhabitants of these types are an idealized subset of llvm, where the only control flow instructions
are breaks and function calls. 

\section{Type rules}
Here we assume all functions and global variables have cle types associated with them.  We will focus on how to infer such types in the next section.
There are several types of judgements, each of which is enumerated below:

\subsection{Judgements}
\begin{enumerate}
    \item $\Gamma \vdash e : \tau$. 
    Top-level entity or instruction $e$ has type $\tau$. 
    \item $\Gamma \vdash b :_\pi \gamma$. 
    Basic block or set of basic blocks $b$ has type $\pi$ for all variables bound in instructions, type $\gamma$ for the terminator.
    \item $\Gamma \vdash t :_\pi \gamma$. 
    Terminator $t$ has type $\gamma$ and all referenced basic blocks, $b$ are given type $_\pi \gamma$.
\end{enumerate}

\subsection{Rules for top-level entities}

\[    
\begin{prooftree}
    \hypo{\tau = l\ \sigma}
    \infer1[global-decl]{\Gamma \vdash @x : \tau}
\end{prooftree}
\qquad
\begin{prooftree}
    \hypo{\tau = l\ \sigma}
    \infer1[global-def]{\Gamma \vdash @x = c : \tau}
\end{prooftree}
\]

\[
\begin{prooftree}
    \hypo{
    \begin{matrix}
        \forall (r\ (\alpha_1, \dots, \alpha_n) \rightarrow_\phi \theta) \in \delta. \ 
        \Gamma[@f \mapsto \tau, \%1 \mapsto l\ \alpha_1, \ldots, \%n \mapsto l\ \alpha_n] \vdash body :_{(l\ \phi)} l\ \theta \\
    \end{matrix}
    }
    \infer1[fn-def]{\Gamma \vdash @f(\%1, \dots, \%n)\ \{ body \} : l\ \delta}
    
\end{prooftree}
\]

\[
\begin{prooftree}
    \hypo{
    \Gamma(@f) = \tau = l\ \delta
    }
    \infer1[fn-def-known]{\Gamma \vdash @f(\%1, \dots, \%n)\ \{ body \} : \tau}
\end{prooftree}
\]

\subsection{Rules for basic blocks and instruction lists}

\[
\begin{prooftree} 
    \hypo{\Gamma \vdash b :_\pi \gamma}
    \hypo{\Gamma, \%b :_\pi \gamma \vdash bbs :_\pi \gamma}
    \infer2[fn-body]{\Gamma \vdash b\ bbs :_\pi \gamma}
\end{prooftree} 
\]


\[
\begin{prooftree} 
    \hypo{\Gamma \vdash instrs : \pi}
    \hypo{\Gamma \vdash term :_\pi \gamma}
    \infer2[bb-unknown]{\Gamma \vdash \%b: instrs\ term :_\pi \gamma}
\end{prooftree} 
\]


\[
\begin{prooftree} 
    \hypo{\Gamma(\%b) =_\pi \gamma} 
    \infer1[bb-known]{\Gamma \vdash \%b: instrs\ term :_\pi \gamma}
\end{prooftree} 
\]


\[
\begin{prooftree} 
    \hypo{\Gamma \vdash instr : \pi}
    \hypo{\Gamma[\%a \mapsto \pi] \vdash instrs : \pi}
    \infer2[instrs]{\Gamma \vdash \%a = instr; instrs : \pi}
\end{prooftree} 
\]

\subsection{Rules for special instructions and terminators}

\[
\begin{prooftree}
    \hypo{\Gamma(\%1) = l\ \alpha_1, \dots, \Gamma(\%n) = l\ \alpha_n}
    \hypo{l\ (\alpha_1, \dots, \alpha_n) \rightarrow_\phi \theta \in \delta}
    \hypo{\Gamma \vdash @f : r\ \delta}
    \infer3[call]{\Gamma \vdash \text{call } @f(\%1, \dots, \%n) : l\ \theta}
\end{prooftree}
\]

\[
\begin{prooftree}
    \hypo{\Gamma(\%a) = \gamma}
    \hypo{\Gamma \vdash \%b_1 :_\pi \gamma} 
    \hypo{\Gamma \vdash \%b_2 :_\pi \gamma} 
    \infer3[break]{\Gamma \vdash \text{br }\%a, \%b_1, \%b_2 :_\pi \gamma}
\end{prooftree}
\]

\[
\begin{prooftree}
    \hypo{\Gamma(\%a) = \gamma}
    \infer1[ret]{\Gamma \vdash \text{ret }\%a :_\pi \gamma}
\end{prooftree}
\]

\subsection{General rule for instructions}

The rules for all other instructions
can be derived from general instruction form which takes in
a number of arguments:
$$\text{instr}\ \%a_1, \dots, \%a_n$$
Thus,

\[
\begin{prooftree}
    \hypo{\Gamma(\%a_1) = \dots = \Gamma(\%a_n) = \pi}
    \infer1[ret]{\Gamma \vdash \text{instr}\ \%a_1, \dots \%a_n : \pi}
\end{prooftree}
\]


\section{Conversion from CLE annotations}



\end{document}
