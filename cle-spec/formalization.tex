\documentclass{article}
\usepackage[utf8]{inputenc}

\title{CLE Type System}
\author{Benjamin Flin}
\date{August 2021}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amssymb, proof, comment, syntax, url, amsthm, ebproof, mathtools}
\begin{document}

\maketitle

\section{Introduction}
\section{CLE Types Grammar}
The following is a small grammar for CLE types $\tau$. 
$l$ and $r$ represent levels and can be thought of as arbitrary identifiers.

\begin{center}
\begin{tabular}{ l r }
    $\tau, \pi, \gamma$ $\Coloneqq$ l $\mu$ $\mid$ l $\sigma$
    & cle type \\ 
    $\mu$ $\Coloneqq$ $r$ ($\sigma_1, \dots, \sigma_n$) $\rightarrow_\phi$ $\theta$ $\mid$ $\mu$ $\cup$ $r$ ($\sigma_1, \dots, \sigma_n$) $\rightarrow_\phi$ $\theta$    
    & cle function cdf \\
    $\sigma, \phi, \theta$ $\Coloneqq$ $\epsilon$ $\mid$ $\sigma \cup r$ 
    & cle var cdf \\
\end{tabular}
\end{center}

\section{LLVM core grammar}

TODO: Change this to make sense

The following source grammar represents an idealized subset of LLVM. 
Many operations are missing, but every missing operation can either be constructed from multiple instructions or is irrelevant to the CLE type inference and checking. 
The rules for cle types in the core grammar should represent the small grammar cle types above.
My references for the grammar construction is from this\footnote{\url{https://lists.llvm.org/pipermail/llvm-dev/2018-June/123851.html}} mail resource.

\begin{grammar}

<prog> ::= empty
\alt <prog> <top-level-entity> 

<top-level-entity> ::= <fun-def>
\alt <fun-decl>
\alt <global-def>
\alt <global-decl>

<global-def> ::= <global-ident> : <type> `=' <const>`;'

<global-decl> ::= <global-ident> : <type> `;'

<fun-def> ::= `define' <global-ident>`(' <params> `)' : <type> <func-body>

<fun-decl> ::= `declare' <global-ident>`(' <params> `)' : <type> `;' 

<params> ::= empty
\alt <param-list>

<param-list> ::= <local-ident>
\alt <param-list>`,' <local-ident> 

<global-ident> ::= `@'<ident>

<local-ident> ::= `\%'<ident>

<func-body> ::= `{' <block-list> `}'

<block-list> ::= <block>
\alt <block-list> <block>

<block> ::= <ident>`:' <instructions> <terminator>

<instructions> ::= empty
\alt <instructions> <instruction>`;'

<instruction> ::= <store-instr> 
\alt <load-instr>
\alt <alloca-instr>
\alt <gep-instr>
\alt <call-instr> 
\alt <binary-instr>
\alt <cast-instr>
\alt <const-instr>

<terminator> ::= <br-term>
\alt <ret-term> 

<decl> ::= <local-ident> : <type>

<store-instr> ::= `store' <value>, <local-ident>

<load-instr> ::= <decl> `=' `load' <value>, <local-ident>

<alloca-instr> ::= <decl> `=' `alloca' <llvm-type> 

<call-instr> ::= <decl> `=' <global-ident>`(' <params> `)'  

<gep-instr> ::= <decl> `=' `gep' <local-ident>`,' <nats> 

<binary-instr> ::= <decl> `=' <value> <binop> <value> 

<cast-instr> ::= <decl> `=' `cast' <local-ident> <llvm-type>  

<nats> ::= <nat>
\alt <nat>, <nats> 

<br-term> ::= `br' <local-ident>, <local-ident>, <local-ident> 
<ret-term> ::= `ret' <local-ident> 

<value> ::= <const>
\alt <local-ident>
\alt <global-ident>

<const> ::= <integer-literal>
\alt <bool-literal>
\alt <float-literal>
\alt <unit-literal>
\alt <struct-const>
\alt <array-const>

<type> ::= <llvm-type> `+' <cle-type>
\alt <llvm-type>

<llvm-type> ::= <int-type>
\alt <float-type>
\alt <unit-type> 
\alt <array-type>
\alt <pointer-type>
\alt <struct-type>
\alt <function-type>

<function-type> ::= `(' <llvm-type-list> `)' `->' <llvm-type>

<array-type> ::= `[' <nat> `x' <llvm-type> `]'

<pointer-type> ::= <llvm-type>`*'

<struct-type> ::= `{' <llvm-type-list> `}'

<llvm-type-list> ::= <llvm-type>
\alt <llvm-type-list>`,' <llvm-type>

<int-type> ::= `i'<nat>

<float-type> ::= `float' 
\alt `double'

<unit-type> ::= `unit'

<cle-type> ::= <level> <cle-fn-cdf> \alt <level> <cle-var-cdf> 

<cle-fn-cdf> ::= 
    <cle-fn-cdf> `|' <level> `(' <cle-args> `)' `['<cle-var-cdf>`]' `->' <cle-var-cdf>
    \alt <level> `(' <cle-args> `)' `['<cle-var-cdf>`]' `->' <cle-var-cdf>


<cle-args> ::= <cle-args>, <cle-var-cdf> \alt empty

<cle-var-cdf> ::=  <cle-var-cdf> `|' <level> \alt empty 

\end{grammar}

\section{Small examples}

This global viarable is in level purple, and is not shareable.
\begin{verbatim}
@foo : i64 + "purple" = 1;
\end{verbatim}


This global variable is in level orange, and is shareable with purple.
\begin{verbatim}
@foo : i64 + "orange" "purple" = 1;
\end{verbatim}


The following function is in level "orange", and has a cdf with remote level "purple".
The first argument is not shareable, 
the second argument is shareable with purple. 
Any variable bound in the body must not be shareable, as well as the return type.

Here I added `empty' in-place of empty fields for clarity. 
\begin{verbatim}
define @average(%0, %1) : (double, double) -> double
 + "orange" "purple" (empty, "purple") [empty] -> empty
      
{
   %2 : double + "orange" = %0 + %1;
   %3 : double + "orange" = %2 / 2.0;
   ret %3
}
\end{verbatim}

\section{Type rules}
Here we assume all functions and global variables have cle types associated with them.  We will focus on how to infer such types in the next section.
CLE is a flow-sensitive model and the types of variables may change as the program is checked.
To reason through this in the system, a type judgement will also include an output context, which may be used in the conclusions of judgements.
Note: Contexts will need to be indexable by level, i.e. every context maps levels to a list of names for that level.
TODO: provide a way to filter contexts by level and to combine contexts.

There are several types of judgements, each of which is enumerated below:

\subsection{Judgements}
\begin{enumerate}
    \item $\Gamma \vdash e : \tau, \Gamma'$. Top-level entity $e$ has type $\tau$ producing a new context $\Gamma'$
    \item $\Gamma \vdash b :_\pi \gamma, \Gamma'$. Basic block or set of basic blocks $b$ has type $\pi$ for all variables bound in instructions, type $\gamma$ for the terminator and produces a new context $\Gamma'$.
\end{enumerate}

\subsection{Rules for top-level entities}

\[    
\begin{prooftree}
    \hypo{\tau = l\ \sigma}
    \infer1[global-decl]{\Gamma \vdash @x : \tau, \Gamma}
\end{prooftree}
\qquad
\begin{prooftree}
    \hypo{\tau = l\ \sigma}
    \infer1[global-def]{\Gamma \vdash @x = c : \tau, \Gamma}
\end{prooftree}
\]

\[
\begin{prooftree}
    \hypo{
    \begin{matrix}
        \Gamma, @f : \tau, \%1 : r_1\ \sigma_{11}, \ldots, \%n: r_1\ \sigma_{1n} \vdash body :_{(l\ \phi_1)} l\ \theta_1, \Gamma'_1 \\
        \vdots \\
        \Gamma, @f : \tau, \%1 : r_m\ \sigma_{m1}, \ldots, \%n: r_m\ \sigma_{mn} \vdash body :_{(l\ \phi_m)} l\ \theta_m, \Gamma'_m \\
        \tau = l\ \bigcup_{k=1}^m r_k (\sigma_{k1}, \dots, \sigma_{kn}) \rightarrow_{\phi_k} \theta_k
    \end{matrix}
    }
    \infer1[fn-def]{\Gamma \vdash @f(\%1, \dots \%n)\ \{ body \} : \tau, \text{combine}(\Gamma'_1, \dots, \Gamma'_m) \setminus \{ @f, \%1, ..., \%n \}  }
    
\end{prooftree}
\]

\[
\begin{prooftree}
    \hypo{\tau = l\ \mu}
    \infer1[fn-decl]{\Gamma \vdash @f : \tau, \Gamma}
\end{prooftree}
\]

\end{document}
