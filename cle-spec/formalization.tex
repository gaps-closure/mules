\documentclass{article}
\usepackage[utf8]{inputenc}

\title{CLE Type System}
\author{Benjamin Flin}
\date{August 2021}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amssymb, proof, comment, syntax, url, amsthm, ebproof, mathtools}
\begin{document}

\maketitle

\section{Introduction}
\section{CLE Types Grammar}
The following is a small grammar for CLE types $\tau$.  

\begin{center}
\begin{tabular}{ l r }
    $\tau$ $\Coloneqq$ $\mu$ $\mid$ $\sigma$
    & cle type \\ 
    $\mu$ $\Coloneqq$ $\omega$ ($\sigma_1, \dots, \sigma_n$) $\rightarrow_\phi$ $\theta$ $\mid$ $\mu$ $\cup$ $\omega$ ($\sigma_1, \dots, \sigma_n$) $\rightarrow_\phi$ $\theta$    
    & cle function type \\
    $\sigma, \phi, \theta$ $\Coloneqq$ $\omega$ $\mid$ $\sigma \cup \omega$ 
    & cle var type \\
    $\omega$ $\Coloneqq$ $l \leftarrow r$ & cross domain flow
\end{tabular}
\end{center}

\section{LLVM core grammar}
The following source grammar represents an idealized subset of LLVM. 
Many operations are missing, but every missing operation can either be constructed from multiple instructions or is irrelevant to the CLE type inference and checking. 
The rules for cle types in the core grammar should represent the small grammar cle types above.
My references for the grammar construction is from this\footnote{\url{https://lists.llvm.org/pipermail/llvm-dev/2018-June/123851.html}} mail resource.

\begin{grammar}

<prog> ::= empty
\alt <prog> <top-level-entity> 

<top-level-entity> ::= <fun-def>
\alt <fun-decl>
\alt <global-def>
\alt <global-decl>

<global-def> ::= <global-ident> : <type> `=' <const>`;'

<global-decl> ::= <global-ident> : <type> `;'

<fun-def> ::= `define' <global-ident>`(' <params> `)' : <type> <func-body>

<fun-decl> ::= `declare' <global-ident>`(' <params> `)' : <type> `;' 

<params> ::= empty
\alt <param-list>

<param-list> ::= <local-ident>
\alt <param-list>`,' <local-ident> 

<global-ident> ::= `@'<ident>

<local-ident> ::= `\%'<ident>

<func-body> ::= `{' <block-list> `}'

<block-list> ::= <block>
\alt <block-list> <block>

<block> ::= <ident>`:' <instructions> <terminator>

<instructions> ::= empty
\alt <instructions> <instruction>`;'

<instruction> ::= <store-instr> 
\alt <load-instr>
\alt <alloca-instr>
\alt <gep-instr>
\alt <call-instr> 
\alt <binary-instr>
\alt <cast-instr>
\alt <const-instr>

<terminator> ::= <br-term>
\alt <ret-term> 

<decl> ::= <local-ident> : <type>

<store-instr> ::= `store' <value>, <local-ident>

<load-instr> ::= <decl> `=' `load' <value>, <local-ident>

<alloca-instr> ::= <decl> `=' `alloca' <llvm-type> 

<call-instr> ::= <decl> `=' <global-ident>`(' <params> `)'  

<gep-instr> ::= <decl> `=' `gep' <local-ident>`,' <nats> 

<binary-instr> ::= <decl> `=' <value> <binop> <value> 

<cast-instr> ::= <decl> `=' `cast' <local-ident> <llvm-type>  

<nats> ::= <nat>
\alt <nat>, <nats> 

<br-term> ::= `br' <local-ident>, <local-ident>, <local-ident> 
<ret-term> ::= `ret' <local-ident> 

<value> ::= <const>
\alt <local-ident>
\alt <global-ident>

<const> ::= <integer-literal>
\alt <bool-literal>
\alt <float-literal>
\alt <unit-literal>
\alt <struct-const>
\alt <array-const>

<type> ::= <llvm-type> `+' <cle-type>
\alt <llvm-type>

<llvm-type> ::= <int-type>
\alt <float-type>
\alt <unit-type> 
\alt <array-type>
\alt <pointer-type>
\alt <struct-type>
\alt <function-type>

<function-type> ::= `(' <llvm-type-list> `)' `->' <llvm-type>

<array-type> ::= `[' <nat> `x' <llvm-type> `]'

<pointer-type> ::= <llvm-type>`*'

<struct-type> ::= `{' <llvm-type-list> `}'

<llvm-type-list> ::= <llvm-type>
\alt <llvm-type-list>`,' <llvm-type>

<int-type> ::= `i'<nat>

<float-type> ::= `float' 
\alt `double'

<unit-type> ::= `unit'

<cle-type> ::= <cle-fn-type> \alt <cle-var-type> 

<cle-fn-type> ::= 
    <cle-fn-type> `|' <cdf> `(' <cle-args> `)' `['<cle-var-type>`]' `->' <cle-var-type>
    \alt <cdf> `(' <cle-args> `)' `['<cle-var-type>`]' `->' <cle-var-type>


<cle-args> ::= <cle-args>, <cle-var-type> \alt empty

<cle-var-type> ::=  <cle-var-type> `|' <cdf> \alt empty 

<cdf> ::= <level> `<-|' <level> 

\end{grammar}

\section{Small examples}

\begin{verbatim}
@foo : i64 + "purple" = 1;
\end{verbatim}


\begin{verbatim}
define @average(%0, %1) : (double, double) -> double
 + "orange" <-| "purple" ("orange", "orange" | "orange" <-| "purple") ["orange"] -> "orange"  
      
{
   %2 : double + "orange" = %0 + %1;
   %3 : double + "orange" = %2 / 2.0;
   ret %3
}
\end{verbatim}

\section{Type rules}

Here we assume all functions and global variables have cle types associated with them. We will focus on how to infer such types in the next section. There are several types of judgements, each of which is enumerated as follows:

Note: Contexts will need to be indexable by level, i.e. every context maps levels to a list of names for that level.
TODO: provide a way to filter contexts by level and to combine contexts.

\subsection{Judgements}
\begin{enumerate}
    \item $\Gamma \vdash e : \tau, \Gamma'$. Top-level entity $e$ has cle type $\tau$ producing a new context $\Gamma'$
    \item $\Gamma \vdash b :_\phi \sigma, \Gamma'$. Basic block or set of basic blocks $b$ has cle var type $\phi$ for all variables bound in instructions and var type $\sigma$ for terminator producing $\Gamma'$.
\end{enumerate}

\subsection{Rules for top-level entities}

\[    
\begin{prooftree}
    \infer0[global-decl]{\Gamma \vdash @x : \tau, \Gamma}
\end{prooftree}
\qquad
\begin{prooftree}
    \infer0[global-def]{\Gamma \vdash @x = c : \tau, \Gamma}
\end{prooftree}
\]

\[
\begin{prooftree}
    \hypo{
    \begin{matrix}
        \Gamma, @f : \tau, \%1 : \sigma_{11}, \ldots, \%n: \sigma_{1n} \vdash body :_{\phi_1} \theta_1, \Gamma'_1 \\
        \vdots \\
        \Gamma, @f : \tau, \%1 : \sigma_{m1}, \ldots, \%n: \sigma_{mn} \vdash body :_{\phi_m} \theta_m, \Gamma'_m \\
        \tau = \bigcup_{k=1}^m \omega_k (\sigma_{k1}, \dots, \sigma_{kn}) \rightarrow_{\phi_k} \theta_k
    \end{matrix}
    }
    \infer1[fn-def]{\Gamma \vdash @f(\%1, \dots \%n)\ \{ body \} : \tau, \text{combine}(\Gamma'_1, \dots, \Gamma'_m) \setminus \{ @f, \sigma_{11}, \dots, \sigma_{mn} \}  }
    
\end{prooftree}
\]

\[
\begin{prooftree}
    \infer0[fn-decl]{\Gamma \vdash @f : (t_1, \ldots, t_n) \rightarrow t + \tau}
\end{prooftree}
\]


\begin{comment}
\infer{\Gamma \vdash i : \tau}{%
    \Gamma\vdash hasFunction(i) \neq \varnothing 
    & \deduce{
        \Gamma, arg_0 : \tau, \dots, arg_n : \tau \vdash
        \forall j. hasSource(j) = i \implies j : \tau 
        }{
        \Gamma \vdash hasParam(i, arg_{0\dots n}) = true
        }
}
\end{comment}


\end{document}
